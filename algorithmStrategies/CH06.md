# CH06 무식하게 풀기
### 소풍
```
import sys

T = int(sys.stdin.readline().rstrip())

def dfs(depth, used, start):
    if depth == n // 2:
        return 1
    ans = 0

    for i in range(start, n):
        if not used[i]:
            used[i] = True
            for j in range(i + 1, n):
                if isFriend[i][j] and not used[j]:
                    used[j] = True
                    ans += dfs(depth + 1, used, i)
                    used[j] = False
            used[i] = False
    return ans

for _ in range(T):
    # n은 학생 수, m은 친구 쌍 수
    n, m = map(int, sys.stdin.readline().rstrip().split())
    friendList = list(map(int, sys.stdin.readline().rstrip().split()))
    isFriend = [[False] * n for _ in range(n)]
    for i in range(0, m * 2, 2):
        isFriend[friendList[i]][friendList[i + 1]] = True
        isFriend[friendList[i + 1]][friendList[i]] = True
    used = [False] * n
    ans = dfs(0, used, 0)
    print(ans)
```

### 게임판 덮기(시간 초과)
```
import sys

# 현재 탐색하는 칸에서 채울 수도 있지만, 채우지 않을 수도 있다.
def fillBlank(graph, x, y):
    if x == n and y == 0:
        for i in range(n):
            for j in range(m):
                if graph[i][j] == '.':
                    return 0
        return 1

    ans = 0
    if graph[x][y] == '.':
        for i in range(4):
            nx1 = x + dx[i]
            ny1 = y + dy[i]
            if nx1 < 0 or nx1 >= n or ny1 < 0 or ny1 >= m or graph[nx1][ny1] == '#':
                continue
            ni = (i + 1) % 4
            nx2 = x + dx[ni]
            ny2 = y + dy[ni]
            if nx2 < 0 or nx2 >= n or ny2 < 0 or ny2 >= m or graph[nx2][ny2] == '#':
                continue
            graph[x][y] = '#'
            graph[nx1][ny1] = '#'
            graph[nx2][ny2] = '#'
            nx = x
            ny = y + 1
            if ny == m:
                ny = 0
                nx += 1
            ans += fillBlank(graph, nx, ny)
            graph[x][y] = '.'
            graph[nx1][ny1] = '.'
            graph[nx2][ny2] = '.'

    nx = x
    ny = y + 1
    if ny == m:
        ny = 0
        nx += 1
    ans += fillBlank(graph, nx, ny)
    return ans

T = int(sys.stdin.readline().rstrip())

dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]

for _ in range(T):
    n, m = map(int, sys.stdin.readline().rstrip().split())
    graph = []
    for _ in range(n):
        graph.append(list(sys.stdin.readline().rstrip()))

    white = 0
    for i in range(n):
        for j in range(m):
            if graph[i][j] == '.':
                white += 1
    if white % 3 != 0:
        print(0)
        continue

    flag = False
    for i in range(n):
        for j in range(m):
            if graph[i][j] == '.':
                x = i
                y = j
                flag = True
                break
        if flag:
            break

    ans = fillBlank(graph, x, y)
    print(ans)
```
-> 하드 코딩 느낌이 있지만 정확도는 높다고 생각하는데 큰 테스트 케이스에서 시간 초과가 난다..
